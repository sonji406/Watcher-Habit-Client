# Watcher Habit: 습관 공유 플랫폼 🌱

<br>

## 💁‍♀️ 소개

**Watcher Habit**은 개인의 습관을 효과적으로 관리하고, 소규모 그룹과 습관을 공유하는 플랫폼입니다. 사용자들이 서로의 습관을 공유하며, 서로를 지켜보면서 동기부여를 얻을 수 있습니다. 이를 통해 습관의 지속성을 높이고, 그룹 내의 동료들과 함께 성장하는 경험을 할 수 있습니다.

> 📹 **시연 영상**: [Watcher Habit 시연 영상 유튜브 링크](https://youtu.be/5N8xgG7dRyc?si=RiP4gVwCZJxXmAK7)

<br>

## 🛠️ 기술 스택

**프론트엔드**

![React](https://img.shields.io/badge/React-18.2.0-61DAFB?logo=React)
![React Router Dom](https://img.shields.io/badge/React%20Router%20Dom-6.15.0-CA4245?logo=react-router)
![React Query](https://img.shields.io/badge/React%20Query-3.39.3-brightgreen)
![Redux](https://img.shields.io/badge/Redux-8.1.2-764ABC?logo=Redux)
![JWT Decode](https://img.shields.io/badge/JWT%20Decode-3.1.2-000000?logo=JSON%20web%20tokens)
![AWS SDK](https://img.shields.io/badge/AWS%20SDK-3.410.0-orange?logo=Amazon%20AWS)
![Axios](https://img.shields.io/badge/Axios-1.5.0-blueviolet)
![TailwindCSS](https://img.shields.io/badge/TailwindCSS-3.3.3-38B2AC?logo=Tailwind%20CSS)
![ESLint](https://img.shields.io/badge/ESLint-9.0.0-4B32C3?logo=ESLint)
![Prettier](https://img.shields.io/badge/Prettier-3.0.3-F7B93E?logo=Prettier)

<br>

**백엔드**

![Node.js](https://img.shields.io/badge/Node.js-LTS-339933?logo=Node.js)
![Express](https://img.shields.io/badge/Express-4.18.2-000000?logo=Express)
![Express Validator](https://img.shields.io/badge/Express%20Validator-7.0.1-brightgreen)
![MongoDB](https://img.shields.io/badge/MongoDB-7.5.0-47A248?logo=MongoDB)
![AWS SDK](https://img.shields.io/badge/AWS%20SDK-2.1458.0-orange?logo=Amazon%20AWS)
![Cron](https://img.shields.io/badge/Cron-2.4.3-111111)
![jsonwebtoken Server](<https://img.shields.io/badge/JSON%20Web%20Tokens%20(Server)-9.0.2-000000?logo=JSON%20web%20tokens>)
![Http Errors](https://img.shields.io/badge/Http%20Errors-1.6.3-red)
![ESLint](https://img.shields.io/badge/ESLint-8.49.0-4B32C3?logo=ESLint)
![Prettier](https://img.shields.io/badge/Prettier-3.0.3-F7B93E?logo=Prettier)

<br>

## 👀 목차

- [💡 프로젝트 동기](#-프로젝트-동기)
  - [1. 개인의 기술적 흥미와 학습 의지](#1-개인의-기술적-흥미와-학습-의지)
  - [2. 습관 기록 아이디어](#2-습관-기록-아이디어)
  - [3. 웹 애플리케이션 Watcher Habit](#3-웹-애플리케이션-watcher-habit)
- [🚧 도전 및 문제 해결](#-도전-및-문제-해결)
  - [3. 실시간 알림](#3-실시간-알림)
    - [1) 실시간 알림의 중요성과 필요성](#1-실시간-알림의-중요성과-필요성)
    - [2) 알림 전송 방법의 선택과 SSE의 도입](#2-알림-전송-방법의-선택과-sse의-도입)
    - [3) 실시간 알림 구현 상세](#3-실시간-알림-구현-상세)
    - [4) 실시간 알림 기능 구현 결과](#4-실시간-알림-기능-구현-결과)
    - [5) SSE의 한계와 웹소켓을 사용하지 않아서 생긴 아쉬운 점](#5-sse의-한계와-웹소켓을-사용하지-않아서-생긴-아쉬운-점)
  - [4. 로그인 과정에서의 보안 고려사항](#4-로그인-과정에서의-보안-고려사항)
    - [1) 사용자의 데이터를 안전하게 저장](#1-사용자의-데이터를-안전하게-저장)
    - [2) 사용자의 데이터 관리를 토큰으로 선택](#2-사용자의-데이터-관리를-토큰으로-선택)
    - [3) 토큰으로 안전하게 관리](#3-토큰으로-안전하게-관리)
      - [(a) 안전한 토큰 저장 방법](#a-안전한-토큰-저장-방법)
      - [(b) 토큰 갱신 메커니즘](#b-토큰-갱신-메커니즘)
      - [(c) 리프레시 토큰 만료 처리](#c-리프레시-토큰-만료-처리)
      - [(d) 쿠키를 이용한 토큰 전달 이슈와 해결](#d-쿠키를-이용한-토큰-전달-이슈와-해결)
    - [4) 구현 결과](#4-구현-결과)
- [🔗 Repository 주소](#-repository-link)

<br>

## 💡 프로젝트 동기

### 1. 개인의 기술적 흥미와 학습 의지

- 신규 기술과 라이브러리 도입 경험
- 안정적인 기술 스택 활용 및 프로젝트 효율성 향상

<br>

### 2. 습관 기록 아이디어

스스로의 습관 형성을 기록하고 있었는데, 혼자만의 기록은 동기 부여에 한계가 있었습니다. 이러한 문제점을 해결하기 위해 습관 기록을 서로 공유하고 확인할 수 있는 소규모 그룹을 형성하는 아이디어가 제시되었습니다. 이 아이디어는 그동안 공부해온 리액트로도 충분히 구현 가능하면서, 관리할 상태가 많을 것으로 예상되었기 때문에 상태 관리 툴의 필요성이 높다고 생각되었습니다. 또, 이전 프로젝트와는 다르게 서버와 클라이언트를 분리하여 작업하는 등 다양한 기술적 도전을 포함하고 있었습니다.

<br>

### 3. 웹 애플리케이션 'Watcher Habit'

모든 팀원의 기술적 흥미와 시환님의 습관 기록 아이디어가 합쳐져, 사용자들이 서로의 습관을 지켜보며 서로를 도와주는 웹 애플리케이션 'Watcher Habit'이 탄생하게 되었습니다. 사용자들에게 서로의 습관을 모니터링하며 동기를 부여하는 서비스입니다.

<br>

## 🚧 도전 및 문제 해결

3주 동안 개발을 진행하면서 겪었던 서버와 클라이언트에서 발생한 핵심적인 문제들을 정리해 보았습니다.

## 1. 실시간 알림

### 1) 실시간 알림의 중요성과 필요성

프로젝트의 핵심 기능 중 하나는 사용자가 어플리케이션 내에서 발생하는 다양한 이벤트들에 대해 실시간으로 알림을 받는 것이었습니다. 이를 통해 사용자는 새로운 그룹 초대, 습관 확인 요청, 알림 승인 요청 등의 이벤트를 즉각적으로 인지하고 반응할 수 있어야 했습니다.

### 2) 알림 전송 방법의 선택과 SSE의 도입

실시간 알림을 구현하기 위한 여러 방법 중, Server-Sent Events (SSE)를 선택한 이유는 다음과 같습니다:

- **간단한 구현**: SSE는 웹 표준 기술로서 구현이 간단하며, 추가적인 라이브러리나 프레임워크 없이도 웹 서버와 브라우저에서 지원됩니다.
- **자동 재연결**: 만약 네트워크 문제로 연결이 끊어졌을 때, SSE는 자동으로 재연결하는 기능을 내장하고 있어, 별도의 재연결 로직을 구현할 필요가 없었습니다.
- **단방향 통신으로 충분히 구현 가능하다고 판단**: 프로젝트에서 필요한 알림은 받기만 하면 서버에서 다른 작업을 해주지 않아도 되는 것으로 기획했기 때문에, 단방향 전송 방법인 SSE로 충분히 구현이 가능했습니다.

![SSE](https://github.com/Last-Survivors-3-8/Watcher-Habit-Server/assets/133510836/d45e0f6b-7da9-4c68-95e1-3f6bc2946bbc)

### 3) 실시간 알림 구현 상세

프로젝트에서는 `initEventSource` 함수를 사용하여 SSE 연결을 초기화하였고, 연결이 성공적으로 이루어지면 서버에서 클라이언트로 알림 데이터를 전송합니다. 이를 수신한 클라이언트는 알림 메시지를 화면에 표시하며, 일정 시간 후에는 자동으로 알림을 화면에서 제거합니다.

### 4) 실시간 알림 기능 구현 결과

SSE를 도입함으로써 사용자는 어플리케이션에서 발생하는 중요한 이벤트들을 실시간으로 확인할 수 있게 되었습니다. 이를 통해 사용자는 필요한 정보나 요청을 즉시 확인하고 처리할 수 있게 되어 사용자 경험의 향상을 이룰 수 있었습니다.

또한, 서버에서 클라이언트로의 실시간 통신 구현으로 인해 프로젝트의 동적인 상호작용이 확대되었습니다.

### 5) SSE의 한계와 웹소켓을 사용하지 않아서 생긴 아쉬운 점

우리 프로젝트에서는 SSE를 사용하여 실시간 알림 기능을 구현하였습니다. SSE에는 다양한 장점이 있지만, 동시에 웹소켓에 비해 몇 가지 한계점이 있습니다.

SSE의 한계

- **단방향** 통신: SSE는 서버에서 클라이언트로의 단방향 통신만 지원합니다. 이로 인해 클라이언트에서의 동작이 서버에 실시간으로 반영되기 어렵습니다. 예를 들면, 알림에서의 특정 액션을 서버에 즉각적으로 반영하는 것이 어렵습니다.

- **지속적 연결 유지**: 많은 사용자가 동시에 SSE 연결을 유지할 경우 서버에 부하가 증가하게 됩니다. 현재 연결된 유저 id를 모두 connection으로 모아놓고 있는데 이 크기가 커지면 서버 내에서 메모리를 계속해서 많이 차지할 수 있기 때문에 부하가 증가하는 요인이 됩니다.

웹소켓의 장점 및 프로젝트에서의 아쉬움

- **양방향 통신**: 웹소켓은 서버와 클라이언트 간의 양방향 통신을 지원합니다. 이로 인해 알림창의 실시간 갱신과 같은 기능을 더 효율적으로 구현할 수 있습니다.

- **알림창 실시간 갱신**: 프로젝트에서는 리액트 쿼리를 사용하여 10초마다 알림을 조회하는 방식을 채택하였습니다. 웹소켓을 사용했다면, 서버에서 신규 알림 발생 시 클라이언트에 즉시 전송하여 알림창을 실시간으로 갱신하는 것이 가능했을 것입니다.

- **효율성 및 네트워크 최적화**: 웹소켓은 데이터를 전송할 때 헤더가 불필요하여, 네트워크의 오버헤드가 적습니다. 따라서, 실제로 알림이 발생했을 때만 데이터를 전송하게 되어 네트워크 리소스를 보다 효율적으로 사용할 수 있습니다.

- **확장성**: 웹소켓은 다양한 실시간 기능에 대한 확장성이 높습니다. 프로젝트의 발전에 따라 다양한 실시간 상호작용 기능을 추가할 때, 웹소켓의 양방향 통신 능력을 활용하면 보다 효과적으로 구현할 수 있었을 것입니다.

결론적으로, SSE는 현재 저희 프로젝트에서 필요한 기능을 빠르고 간편하게 구현하는 데에는 충분하였습니다. 하지만 미래의 프로젝트 확장성을 고려한다면, 웹소켓은 많은 기능을 보다 효과적으로 구현할 수 있는 강력한 도구로 작용할 것 같습니다. 따라서, 다음 단계의 개발에서는 웹소켓의 도입 및 활용을 고려해볼 필요가 있다고 생각됩니다. 이를 통해 사용자 경험을 더욱 향상시키고, 프로젝트의 기술적 한계를 넓힐 수 있을 것으로 기대됩니다.

<br>

## 2. 로그인 과정에서의 보안 고려사항

### 1) 사용자의 데이터를 안전하게 저장

왓처해빗에서는 로그인을 통해 사용자의 데이터를 서버에 안전하게 저장하며, 어느 기기에서나 언제든 접근할 수 있도록 JWT 토큰 기반의 로그인을 구현했습니다.
이때 주요 고려사항은 클라이언트 측에서 토큰을 어떻게 안전하게 저장하며, 토큰의 갱신과 만료 처리를 어떻게 진행할 것인지였습니다.

### 2) 사용자의 데이터 관리를 토큰으로 선택

1. XSS 공격으로부터 보호할 수 있는 토큰 저장 방법
2. 사용자의 토큰이 탈취당하는 악용을 막는 방법

### 3) 토큰으로 안전하게 관리

#### (a) 안전한 토큰 저장 방법

- JavaScript 접근을 차단하는 HttpOnly 쿠키 선택

#### (b) 토큰 갱신 메커니즘

![token](https://github.com/Last-Survivors-3-8/Watcher-Habit-Client/assets/133579214/268c193f-c2e3-4197-a6e9-a16d762c4b00)

- 액세스 토큰의 수명을 짧게 하고, 리프레시 토큰을 사용하여 만료된 액세스 토큰을 재발급
  - **Axios Interceptors를 활용한 토큰 재발급 메커니즘**
    Axios의 Interceptors 기능을 활용하여 API 호출 전에 토큰의 유효성을 검증하고, 만약 토큰이 만료되었을 경우, 리프레시 토큰을 통해 새로운 액세스 토큰을 받아와서 API 호출을 수행하도록 구현하였습니다.

#### (c) 리프레시 토큰 만료 처리

- 리프레시 토큰 만료 시 사용자를 로그인 페이지로 리다이렉트

#### (d) 쿠키를 이용한 토큰 전달 이슈와 해결

- **이슈:** 로컬에서 쿠키를 통한 토큰 전달 문제 발생
- **해결:** CORS 설정 수정 및 **`withCredentials`** 옵션 활성화

### 4) 구현 결과

쿠키와 CORS 설정의 중요성을 인식하고, 이를 통해 클라이언트와 서버 간의 보안 문제를 해결하였습니다.

<br>

## 🔗 Repository Link

- [Watcher-Habit 클라이언트 Repository](https://github.com/Last-Survivors-3-8/Watcher-Habit-Client)
- [Watcher-Habit 서버 Repository](https://github.com/Last-Survivors-3-8/Watcher-Habit-Server)

